var documenterSearchIndex = {"docs":
[{"location":"api/querybuilder.html","page":"QueryBuilder","title":"QueryBuilder","text":"@```@meta CurrentModule = QueryBuilder","category":"page"},{"location":"api/querybuilder.html","page":"QueryBuilder","title":"QueryBuilder","text":"","category":"page"},{"location":"api/querybuilder.html","page":"QueryBuilder","title":"QueryBuilder","text":"@contents","category":"page"},{"location":"api/querybuilder.html","page":"QueryBuilder","title":"QueryBuilder","text":"","category":"page"},{"location":"api/querybuilder.html","page":"QueryBuilder","title":"QueryBuilder","text":"@docs MissingModel QueryPart from select where limit offset order group having prepare","category":"page"},{"location":"api/querybuilder.html","page":"QueryBuilder","title":"QueryBuilder","text":"","category":"page"},{"location":"api/querybuilder.html","page":"QueryBuilder","title":"QueryBuilder","text":"DataFrames.DataFrame SearchLight.find SearchLight.first SearchLight.last SearchLight.count SearchLight.sql ```","category":"page"},{"location":"api/callbacks.html","page":"Callbacks","title":"Callbacks","text":"@```@meta CurrentModule = Callbacks","category":"page"},{"location":"api/callbacks.html","page":"Callbacks","title":"Callbacks","text":"","category":"page"},{"location":"api/callbacks.html","page":"Callbacks","title":"Callbacks","text":"@contents","category":"page"},{"location":"api/callbacks.html","page":"Callbacks","title":"Callbacks","text":"","category":"page"},{"location":"api/callbacks.html","page":"Callbacks","title":"Callbacks","text":"@docs onexception onfind afterfind onsave beforesave aftersave ```","category":"page"},{"location":"api/serializers/json.html","page":"JsonSerializer","title":"JsonSerializer","text":"@```@meta CurrentModule = JsonSerializer","category":"page"},{"location":"api/serializers/json.html","page":"JsonSerializer","title":"JsonSerializer","text":"","category":"page"},{"location":"api/serializers/json.html","page":"JsonSerializer","title":"JsonSerializer","text":"@contents","category":"page"},{"location":"api/serializers/json.html","page":"JsonSerializer","title":"JsonSerializer","text":"","category":"page"},{"location":"api/serializers/json.html","page":"JsonSerializer","title":"JsonSerializer","text":"@docs SearchLight.Serializer.serialize SearchLight.Serializer.deserialize ```","category":"page"},{"location":"api/searchlight.html","page":"SearchLight","title":"SearchLight","text":"CurrentModule = SearchLight","category":"page"},{"location":"api/searchlight.html","page":"SearchLight","title":"SearchLight","text":"","category":"page"},{"location":"api/searchlight.html","page":"SearchLight","title":"SearchLight","text":"connect\ndisconnect\nconnection\nUnsupportedException\nDataFrames.DataFrame\nfind\nonereduce\nfindone\none\nrandone\nall\nfirst\nlast\nsave\nsave!\nsave!!\n_save!!\nupdatewith!\nconvertmethod\nbooltypes\nautoconvert\nupdatewith!!\nupdatewith\ncreatewith\nupdateby_or_create\nupdate_or_create\nfindone_or_create\nto_models\nto_model\nto_model!!\nto_select_part\nto_from_part\nto_where_part\nto_order_part\nto_group_part\nto_limit_part\nto_offset_part\nto_having_part\nto_join_part\ncolumns_from_joins\ncolumn_data_to_column_name\nprepare_column_name\ncolumns_names_by_table\ndataframes_by_table\nto_find_sql\nto_fetch_sql\nto_store_sql\nto_sqlinput\ndelete_all\ndeleteall\ndelete\nquery\nclone\ncolumns\nispersisted\ncolumn_field_name\npersistable_fields\nsettable_fields\ntable\npk\nprimary_key_name\nstrip_table_name\nis_fully_qualified\nfrom_fully_qualified\nstrip_module_name\nto_fully_qualified\nto_sql_column_names\nto_sql_column_name\nto_fully_qualified_sql_column_names\nfo_fully_qualified_sql_column_name\nfrom_literal_column_name\nto_dict\nto_string_dict\nenclosure\nupdate_query_part\nescape_column_name\nescape_value\nindex_name\nsql\nadd_quotes\nstrip_quotes\nisquoted\nexpand_nullable\nCore.NamedTuple","category":"page"},{"location":"api/searchlight.html#DataFrames.DataFrame","page":"SearchLight","title":"DataFrames.DataFrame","text":"DataFrame <: AbstractDataFrame\n\nAn AbstractDataFrame that stores a set of named columns\n\nThe columns are normally AbstractVectors stored in memory, particularly a Vector or CategoricalVector.\n\nConstructors\n\nDataFrame(pairs::Pair...; makeunique::Bool=false, copycols::Bool=true)\nDataFrame(pairs::AbstractVector{<:Pair}; makeunique::Bool=false, copycols::Bool=true)\nDataFrame(ds::AbstractDict; copycols::Bool=true)\nDataFrame(kwargs..., copycols::Bool=true)\n\nDataFrame(columns::AbstractVecOrMat,\n          names::AbstractVector;\n          makeunique::Bool=false, copycols::Bool=true)\n\nDataFrame(table; copycols::Union{Bool, Nothing}=nothing)\nDataFrame(::DataFrameRow)\nDataFrame(::GroupedDataFrame; keepkeys::Bool=true)\n\nKeyword arguments\n\ncopycols : whether vectors passed as columns should be copied; by default set to true and the vectors are copied; if set to false then the constructor will still copy the passed columns if it is not possible to construct a DataFrame without materializing new columns. Note the copycols=nothing default in the Tables.jl compatible constructor; it is provided as certain input table types may have already made a copy of columns or the columns may otherwise be immutable, in which case columns are not copied by default. To force a copy in such cases, or to get mutable columns from an immutable input table (like Arrow.Table), pass copycols=true explicitly.\nmakeunique : if false (the default), an error will be raised\n\n(note that not all constructors support these keyword arguments)\n\nDetails on behavior of different constructors\n\nIt is allowed to pass a vector of Pairs, a list of Pairs as positional arguments, or a list of keyword arguments. In this case each pair is considered to represent a column name to column value mapping and column name must be a Symbol or string. Alternatively a dictionary can be passed to the constructor in which case its entries are considered to define the column name and column value pairs. If the dictionary is a Dict then column names will be sorted in the returned DataFrame.\n\nIn all the constructors described above column value can be a vector which is consumed as is or an object of any other type (except AbstractArray). In the latter case the passed value is automatically repeated to fill a new vector of the appropriate length. As a particular rule values stored in a Ref or a 0-dimensional AbstractArray are unwrapped and treated in the same way.\n\nIt is also allowed to pass a vector of vectors or a matrix as as the first argument. In this case the second argument must be a vector of Symbols or strings specifying column names, or the symbol :auto to generate column names x1, x2, ... automatically. Note that in this case if the first argument is a matrix and copycols=false the columns of the created DataFrame will be views of columns the source matrix.\n\nIf a single positional argument is passed to a DataFrame constructor then it is assumed to be of type that implements the Tables.jl interface using which the returned DataFrame is materialized.\n\nFinally it is allowed to construct a DataFrame from a DataFrameRow or a GroupedDataFrame. In the latter case the keepkeys keyword argument specifies whether the resulting DataFrame should contain the grouping columns of the passed GroupedDataFrame and the order of rows in the result follows the order of groups in the GroupedDataFrame passed.\n\nNotes\n\nThe DataFrame constructor by default copies all columns vectors passed to it. Pass the copycols=false keyword argument (where supported) to reuse vectors without copying them.\n\nBy default an error will be raised if duplicates in column names are found. Pass makeunique=true keyword argument (where supported) to accept duplicate names, in which case they will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf an AbstractRange is passed to a DataFrame constructor as a column it is always collected to a Vector (even if copycols=false). As a general rule AbstractRange values are always materialized to a Vector by all functions in DataFrames.jl before being stored in a DataFrame.\n\nDataFrame can store only columns that use 1-based indexing. Attempting to store a vector using non-standard indexing raises an error.\n\nThe DataFrame type is designed to allow column types to vary and to be dynamically changed also after it is constructed. Therefore DataFrames are not type stable. For performance-critical code that requires type-stability either use the functionality provided by select/transform/combine functions, use Tables.columntable and Tables.namedtupleiterator functions, use barrier functions, or provide type assertions to the variables that hold columns extracted from a DataFrame.\n\nExamples\n\njulia> DataFrame((a=[1, 2], b=[3, 4])) # Tables.jl table constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      3\n   2 │     2      4\n\njulia> DataFrame([(a=1, b=0), (a=2, b=0)]) # Tables.jl table constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame(\"a\" => 1:2, \"b\" => 0) # Pair constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([:a => 1:2, :b => 0]) # vector of Pairs constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame(Dict(:a => 1:2, :b => 0)) # dictionary constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame(a=1:2, b=0) # keyword argument constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([[1, 2], [0, 0]], [:a, :b]) # vector of vectors constructor\n2×2 DataFrame\n Row │ a      b\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\njulia> DataFrame([1 0; 2 0], :auto) # matrix constructor\n2×2 DataFrame\n Row │ x1     x2\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      0\n   2 │     2      0\n\n\n\n\n\n","category":"type"},{"location":"api/searchlight.html#Base.one","page":"SearchLight","title":"Base.one","text":"one(x)\none(T::type)\n\nReturn a multiplicative identity for x: a value such that one(x)*x == x*one(x) == x.  Alternatively one(T) can take a type T, in which case one returns a multiplicative identity for any x of type T.\n\nIf possible, one(x) returns a value of the same type as x, and one(T) returns a value of type T.  However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless.  In that case, one(x) should return an identity value of the same precision (and shape, for matrices) as x.\n\nIf you want a quantity that is of the same type as x, or of type T, even if x is dimensionful, use oneunit instead.\n\nSee also the identity function, and I in LinearAlgebra for the identity matrix.\n\nExamples\n\njulia> one(3.7)\n1.0\n\njulia> one(Int)\n1\n\njulia> import Dates; one(Dates.Day(1))\n1\n\n\n\n\n\n","category":"function"},{"location":"api/searchlight.html#Base.all","page":"SearchLight","title":"Base.all","text":"all(itr) -> Bool\n\nTest whether all elements of a boolean collection are true, returning false as soon as the first false value in itr is encountered (short-circuiting). To short-circuit on true, use any.\n\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\n\nSee also: all!, any, count, &, , &&, allunique.\n\nExamples\n\njulia> a = [true,false,false,true]\n4-element Vector{Bool}:\n 1\n 0\n 0\n 1\n\njulia> all(a)\nfalse\n\njulia> all((println(i); v) for (i, v) in enumerate(a))\n1\n2\nfalse\n\njulia> all([missing, false])\nfalse\n\njulia> all([true, missing])\nmissing\n\n\n\n\n\nall(p, itr) -> Bool\n\nDetermine whether predicate p returns true for all elements of itr, returning false as soon as the first item in itr for which p returns false is encountered (short-circuiting). To short-circuit on true, use any.\n\nIf the input contains missing values, return missing if all non-missing values are true (or equivalently, if the input contains no false value), following three-valued logic.\n\nExamples\n\njulia> all(i->(4<=i<=6), [4,5,6])\ntrue\n\njulia> all(i -> (println(i); i < 3), 1:10)\n1\n2\n3\nfalse\n\njulia> all(i -> i > 0, [1, missing])\nmissing\n\njulia> all(i -> i > 0, [-1, missing])\nfalse\n\njulia> all(i -> i > 0, [1, 2])\ntrue\n\n\n\n\n\nall(A; dims)\n\nTest whether all values along the given dimensions of an array are true.\n\nExamples\n\njulia> A = [true false; true true]\n2×2 Matrix{Bool}:\n 1  0\n 1  1\n\njulia> all(A, dims=1)\n1×2 Matrix{Bool}:\n 1  0\n\njulia> all(A, dims=2)\n2×1 Matrix{Bool}:\n 0\n 1\n\n\n\n\n\nall(p, A; dims)\n\nDetermine whether predicate p returns true for all elements along the given dimensions of an array.\n\nExamples\n\njulia> A = [1 -1; 2 2]\n2×2 Matrix{Int64}:\n 1  -1\n 2   2\n\njulia> all(i -> i > 0, A, dims=1)\n1×2 Matrix{Bool}:\n 1  0\n\njulia> all(i -> i > 0, A, dims=2)\n2×1 Matrix{Bool}:\n 0\n 1\n\n\n\n\n\n","category":"function"},{"location":"api/searchlight.html#Base.first","page":"SearchLight","title":"Base.first","text":"first(coll)\n\nGet the first element of an iterable collection. Return the start point of an AbstractRange even if it is empty.\n\nSee also: only, firstindex, last.\n\nExamples\n\njulia> first(2:2:10)\n2\n\njulia> first([1; 2; 3; 4])\n1\n\n\n\n\n\nfirst(itr, n::Integer)\n\nGet the first n elements of the iterable collection itr, or fewer elements if itr is not long enough.\n\nSee also: startswith, Iterators.take.\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\nExamples\n\njulia> first([\"foo\", \"bar\", \"qux\"], 2)\n2-element Vector{String}:\n \"foo\"\n \"bar\"\n\njulia> first(1:6, 10)\n1:6\n\njulia> first(Bool[], 1)\nBool[]\n\n\n\n\n\nfirst(s::AbstractString, n::Integer)\n\nGet a string consisting of the first n characters of s.\n\nExamples\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 1)\n\"∀\"\n\njulia> first(\"∀ϵ≠0: ϵ²>0\", 3)\n\"∀ϵ≠\"\n\n\n\n\n\nfirst(q::Deque)\n\nReturns the first element of the deque q.\n\n\n\n\n\nfirst(D::CircularDeque)\n\nGet the item at the front of the queue.\n\n\n\n\n\nfirst(s::Stack)\n\nGet the top item from the stack. Sometimes called peek.\n\n\n\n\n\nfirst(h::BinaryHeap)\n\nReturns the element at the top of the heap h.\n\n\n\n\n\nfirst(h::BinaryMinMaxHeap)\n\nGet the first (minimum) of the heap.\n\n\n\n\n\nfirst(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the first item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, first(sc) is equivalent to deref((sc,startof(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\nfirst(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the first item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, first(sc) is equivalent to deref((sc,startof(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\nfirst(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the first item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, first(sc) is equivalent to deref((sc,startof(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\nfirst(cb::CircularBuffer)\n\nGet the first element of CircularBuffer.\n\n\n\n\n\nfirst(df::AbstractDataFrame)\n\nGet the first row of df as a DataFrameRow.\n\n\n\n\n\nfirst(df::AbstractDataFrame, n::Integer; view::Bool=false)\n\nGet a data frame with the n first rows of df.\n\nIf view=false a freshly allocated DataFrame is returned. If view=true then a SubDataFrame view into df is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/searchlight.html#Base.last","page":"SearchLight","title":"Base.last","text":"last(coll)\n\nGet the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling lastindex to get the last index. Return the end point of an AbstractRange even if it is empty.\n\nSee also first, endswith.\n\nExamples\n\njulia> last(1:2:10)\n9\n\njulia> last([1; 2; 3; 4])\n4\n\n\n\n\n\nlast(itr, n::Integer)\n\nGet the last n elements of the iterable collection itr, or fewer elements if itr is not long enough.\n\ncompat: Julia 1.6\nThis method requires at least Julia 1.6.\n\nExamples\n\njulia> last([\"foo\", \"bar\", \"qux\"], 2)\n2-element Vector{String}:\n \"bar\"\n \"qux\"\n\njulia> last(1:6, 10)\n1:6\n\njulia> last(Float64[], 1)\nFloat64[]\n\n\n\n\n\nlast(s::AbstractString, n::Integer)\n\nGet a string consisting of the last n characters of s.\n\nExamples\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 0)\n\"\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 1)\n\"0\"\n\njulia> last(\"∀ϵ≠0: ϵ²>0\", 3)\n\"²>0\"\n\n\n\n\n\nlast(q::Deque)\n\nReturns the last element of the deque q.\n\n\n\n\n\nlast(D::CircularDeque)\n\nGet the item from the back of the queue.\n\n\n\n\n\nlast(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the last item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, last(sc) is equivalent to deref((sc,lastindex(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\nlast(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the last item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, last(sc) is equivalent to deref((sc,lastindex(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\nlast(sc)\n\nArgument sc is a SortedDict, SortedMultiDict or SortedSet. This function returns the last item (a k=>v pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, last(sc) is equivalent to deref((sc,lastindex(sc))). It is an error to call this function on an empty container. Time: O(log n)\n\n\n\n\n\nlast(cb::CircularBuffer)\n\nGet the last element of CircularBuffer.\n\n\n\n\n\nlast(df::AbstractDataFrame)\n\nGet the last row of df as a DataFrameRow.\n\n\n\n\n\nlast(df::AbstractDataFrame, n::Integer; view::Bool=false)\n\nGet a data frame with the n last rows of df.\n\nIf view=false a freshly allocated DataFrame is returned. If view=true then a SubDataFrame view into df is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/searchlight.html#SearchLight.columns_from_joins","page":"SearchLight","title":"SearchLight.columns_from_joins","text":"columnsfromjoins(joins::Vector{SQLJoin})::Vector{SQLColumn}\n\nExtracts columns from joins param and adds to be used for the SELECT part\n\n\n\n\n\n","category":"function"},{"location":"api/searchlight.html#SearchLight.escape_column_name","page":"SearchLight","title":"SearchLight.escape_column_name","text":"escape_column_name(c::SQLColumn) :: SQLColumn\nescape_column_name(s::String)\n\nSanitizes input to be use as column names in SQL queries.\n\n\n\n\n\n","category":"function"},{"location":"api/searchlight.html#SearchLight.escape_value","page":"SearchLight","title":"SearchLight.escape_value","text":"escape_value(i::SQLInput)\n\nSanitizes input to be used as values in SQL queries.\n\n\n\n\n\n","category":"function"},{"location":"api/searchlight.html#SearchLight.add_quotes","page":"SearchLight","title":"SearchLight.add_quotes","text":"add_quotes(str::String) :: String\n\nAdds quotes around str and escapes any previously existing quotes.\n\n\n\n\n\n","category":"function"},{"location":"api/searchlight.html#SearchLight.strip_quotes","page":"SearchLight","title":"SearchLight.strip_quotes","text":"strip_quotes(str::String) :: String\n\nUnquotes str.\n\n\n\n\n\n","category":"function"},{"location":"api/searchlight.html#SearchLight.isquoted","page":"SearchLight","title":"SearchLight.isquoted","text":"isquoted(str::String) :: Bool\n\nChecks weather or not str is quoted.\n\n\n\n\n\n","category":"function"},{"location":"api/searchlight.html#SearchLight.expand_nullable","page":"SearchLight","title":"SearchLight.expand_nullable","text":"expand_nullable{T}(value::Union{Nothing,T}, default::T) :: T\n\nReturns value if it is not nothing - otherwise default.\n\n\n\n\n\n","category":"function"},{"location":"api/searchlight.html#Core.NamedTuple","page":"SearchLight","title":"Core.NamedTuple","text":"NamedTuple\n\nNamedTuples are, as their name suggests, named Tuples. That is, they're a tuple-like collection of values, where each entry has a unique name, represented as a Symbol. Like Tuples, NamedTuples are immutable; neither the names nor the values can be modified in place after construction.\n\nAccessing the value associated with a name in a named tuple can be done using field access syntax, e.g. x.a, or using getindex, e.g. x[:a] or x[(:a, :b)]. A tuple of the names can be obtained using keys, and a tuple of the values can be obtained using values.\n\nnote: Note\nIteration over NamedTuples produces the values without the names. (See example below.) To iterate over the name-value pairs, use the pairs function.\n\nThe @NamedTuple macro can be used for conveniently declaring NamedTuple types.\n\nExamples\n\njulia> x = (a=1, b=2)\n(a = 1, b = 2)\n\njulia> x.a\n1\n\njulia> x[:a]\n1\n\njulia> x[(:a,)]\n(a = 1,)\n\njulia> keys(x)\n(:a, :b)\n\njulia> values(x)\n(1, 2)\n\njulia> collect(x)\n2-element Vector{Int64}:\n 1\n 2\n\njulia> collect(pairs(x))\n2-element Vector{Pair{Symbol, Int64}}:\n :a => 1\n :b => 2\n\nIn a similar fashion as to how one can define keyword arguments programmatically, a named tuple can be created by giving a pair name::Symbol => value or splatting an iterator yielding such pairs after a semicolon inside a tuple literal:\n\njulia> (; :a => 1)\n(a = 1,)\n\njulia> keys = (:a, :b, :c); values = (1, 2, 3);\n\njulia> (; zip(keys, values)...)\n(a = 1, b = 2, c = 3)\n\nAs in keyword arguments, identifiers and dot expressions imply names:\n\njulia> x = 0\n0\n\njulia> t = (; x)\n(x = 0,)\n\njulia> (; t.x)\n(x = 0,)\n\ncompat: Julia 1.5\nImplicit names from identifiers and dot expressions are available as of Julia 1.5.\n\ncompat: Julia 1.7\nUse of getindex methods with multiple Symbols is available as of Julia 1.7.\n\n\n\n\n\n","category":"type"},{"location":"api/configuration.html","page":"Configuration","title":"Configuration","text":"@```@meta CurrentModule = Configuration","category":"page"},{"location":"api/configuration.html","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"api/configuration.html","page":"Configuration","title":"Configuration","text":"@contents","category":"page"},{"location":"api/configuration.html","page":"Configuration","title":"Configuration","text":"","category":"page"},{"location":"api/configuration.html","page":"Configuration","title":"Configuration","text":"@docs env readdbconnection_data load Settings ```","category":"page"},{"location":"api/migrations.html","page":"Migrations","title":"Migrations","text":"@```@meta CurrentModule = Migration","category":"page"},{"location":"api/migrations.html","page":"Migrations","title":"Migrations","text":"","category":"page"},{"location":"api/migrations.html","page":"Migrations","title":"Migrations","text":"@contents","category":"page"},{"location":"api/migrations.html","page":"Migrations","title":"Migrations","text":"","category":"page"},{"location":"api/migrations.html","page":"Migrations","title":"Migrations","text":"@docs DatabaseMigration IrreversibleMigrationException ExistingMigrationException MigrationNotFoundException newtable newtable relationshiptablename new migrationhash migrationfilename migrationmodulename lastup lastup lastdown lastdown up upbymodulename down downbymodulename migrationbymodulename allmigrations all lastmigration last runmigration storemigrationstatus uppedmigrations downedmigrations status allwithstatus alldown!! allup!! createtable column columns columnid addindex addindexes addcolumn addcolumns droptable removecolumn removecolumns removeindex removeindexes removeindices createsequence constraint nextval columnidsequence removesequence dropsequence createmigrations_table init ```","category":"page"},{"location":"api/transactions.html","page":"Transactions","title":"Transactions","text":"@```@meta CurrentModule = Transactions","category":"page"},{"location":"api/transactions.html","page":"Transactions","title":"Transactions","text":"","category":"page"},{"location":"api/transactions.html","page":"Transactions","title":"Transactions","text":"@contents","category":"page"},{"location":"api/transactions.html","page":"Transactions","title":"Transactions","text":"","category":"page"},{"location":"api/transactions.html","page":"Transactions","title":"Transactions","text":"@docs begintransaction committransaction rollbacktransaction transaction withtransaction ```","category":"page"},{"location":"api/filetemplates.html","page":"FileTemplates","title":"FileTemplates","text":"@```@meta CurrentModule = FileTemplates","category":"page"},{"location":"api/filetemplates.html","page":"FileTemplates","title":"FileTemplates","text":"","category":"page"},{"location":"api/filetemplates.html","page":"FileTemplates","title":"FileTemplates","text":"@contents","category":"page"},{"location":"api/filetemplates.html","page":"FileTemplates","title":"FileTemplates","text":"","category":"page"},{"location":"api/filetemplates.html","page":"FileTemplates","title":"FileTemplates","text":"@docs newtablemigration newrelationshiptablemigration newmigration newmodel newvalidator adapterdefault_config newconfig newtest ```","category":"page"},{"location":"api/generator.html","page":"Generator","title":"Generator","text":"@```@meta CurrentModule = Generator","category":"page"},{"location":"api/generator.html","page":"Generator","title":"Generator","text":"","category":"page"},{"location":"api/generator.html","page":"Generator","title":"Generator","text":"@contents","category":"page"},{"location":"api/generator.html","page":"Generator","title":"Generator","text":"","category":"page"},{"location":"api/generator.html","page":"Generator","title":"Generator","text":"@docs newmodel newresource newtablemigration newmigration setupresourcepath writeresourcefile newconfig resourcedoesnotexist modelfilename validatorfile_name ```","category":"page"},{"location":"api/exceptions.html","page":"Exceptions","title":"Exceptions","text":"@```@meta CurrentModule = Exceptions","category":"page"},{"location":"api/exceptions.html","page":"Exceptions","title":"Exceptions","text":"","category":"page"},{"location":"api/exceptions.html","page":"Exceptions","title":"Exceptions","text":"@contents","category":"page"},{"location":"api/exceptions.html","page":"Exceptions","title":"Exceptions","text":"","category":"page"},{"location":"api/exceptions.html","page":"Exceptions","title":"Exceptions","text":"@docs SearchLightException NotPersistedException MissingDatabaseConfigurationException NotConnectedException UnretrievedModelException InvalidModelException TypeConversionException MissingConversionMethodException","category":"page"},{"location":"api/relationships.html","page":"Relationships","title":"Relationships","text":"@```@meta CurrentModule = Relationships","category":"page"},{"location":"api/relationships.html","page":"Relationships","title":"Relationships","text":"","category":"page"},{"location":"api/relationships.html","page":"Relationships","title":"Relationships","text":"@contents","category":"page"},{"location":"api/relationships.html","page":"Relationships","title":"Relationships","text":"","category":"page"},{"location":"api/relationships.html","page":"Relationships","title":"Relationships","text":"@docs createrelationshipmigration relationshipname relationshipfield_name Relationship Relationship! related isrelated ```","category":"page"},{"location":"api/serializer.html","page":"Serializer","title":"Serializer","text":"@```@meta CurrentModule = Serializer","category":"page"},{"location":"api/serializer.html","page":"Serializer","title":"Serializer","text":"","category":"page"},{"location":"api/serializer.html","page":"Serializer","title":"Serializer","text":"@contents","category":"page"},{"location":"api/serializer.html","page":"Serializer","title":"Serializer","text":"","category":"page"},{"location":"api/serializer.html","page":"Serializer","title":"Serializer","text":"@docs serialize deserialize serializables ```","category":"page"},{"location":"api/validation.html","page":"Validation","title":"Validation","text":"CurrentModule = Validation","category":"page"},{"location":"api/validation.html","page":"Validation","title":"Validation","text":"","category":"page"},{"location":"api/validation.html","page":"Validation","title":"Validation","text":"ValidationAbstractType\nValidationResult\nValidationError\nValidationRule\nModelValidator\nvalidator\nvalidate\nhaserrors\nhaserrorsfor\nerrorsfor\nerrorsmessagesfor\nerrors_to_string","category":"page"},{"location":"api/validation.html#SearchLight.Validation.ModelValidator","page":"Validation","title":"SearchLight.Validation.ModelValidator","text":"The object that defines the rules and stores the validation errors associated with the fields of a model.\n\n\n\n\n\n","category":"type"},{"location":"api/validation.html#SearchLight.Validation.validate","page":"Validation","title":"SearchLight.Validation.validate","text":"validate(m::T)::Bool where {T<:AbstractModel}\n\nValidates m's data. A bool is return and existing errors are pushed to the validator's error stack.\n\n\n\n\n\n","category":"function"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: SearchLight Logo)","category":"page"},{"location":"index.html#SearchLight-Concise,-secure,-cross-platform-query-builder-and-ORM-for-Julia.","page":"Home","title":"SearchLight - Concise, secure, cross-platform query builder and ORM for Julia.","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"SearchLight supports SQLite, MySQL/MariaDB and Postgres, offering powerful features like data modelling, query generation, validation, database schema migrations, relationships, data serialisation, and more.","category":"page"}]
}
